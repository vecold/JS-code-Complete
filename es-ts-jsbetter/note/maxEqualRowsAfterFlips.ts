
/**
 * 给定由若干 0 和 1 组成的矩阵 matrix，从中选出任意数量的列并翻转其上的 每个 单元格。翻转后，单元格的值从 0 变成 1，或者从 1 变为 0 。

  经过一些翻转后，返回行与行之间所有值都相等的最大行数。
  输入：[
    [0,0,0],
    [0,0,1],
    [1,1,0]
  ]
  输出：2
  解释：翻转前两列的值之后，后两行由相等的值组成。
 * @param {number[][]} matrix
 * @return {number}
 */
//思路一 如果我要使第一行全等我要翻转哪些列，然后 以这些翻转的列放到所有的行上，看看哪些是完全相同的 // 写法1复杂度很高 
// 我想让一行全部变成1或者0 我该翻哪些牌子 尝试写法2 用每一行的翻转列当key值
// 
var maxEqualRowsAfterFlips = function(matrix) {
  let str = '';
  let obj: {[key:string]:number} = {};
  matrix.forEach((value,index) => {
    str = '';
    if(value[0] === 1) {
      str = value.map(item=> 1 ^ item).join('');
    } else {
      str = value.join('');
    }
    obj[str] = obj[str] ? obj[str] + 1 : 1;
  });
  return Math.max(...Object.values(obj));
};
console.log(maxEqualRowsAfterFlips([[0,1],[1,0]]));

// 有一个 非常有意思的规律
// 两行 [0,1,0] 与 [1,0,1] ： [0,1,0]经过 [1,0,1] （1翻0不翻转）的翻转后能变成 全是1  而 [1,0,1]经过 [0,1,0] 也能全是1
// [1,1,0,1] 与 [0,0,1,0] 忽然发现 ！ 其实可以将一个作为另外一个的key直接使用 [0,0,1,0]这个东西完全可以按照 [0,0,1,0]翻转 全是0 
// 诶好巧哦 ， 你也可以这么翻吗 嘿嘿嘿
// 写法3改进
// 思路 4 因为只有 0和1 所以可以按照数字出现的顺序来翻转 11100110 -> 3221 只要顺序是一样的，那么就可以翻转成 要么都是 0 要么都是 1
// 数学解释
// 有一个异或